---
// Array of available images for the mosaic
const mosaicImages: number[] = Array.from({ length: 23 }, (_, i) => i + 1)

function initImageModal(): void {
  // Create modal elements - only when first needed (lazy initialization)
  const createModal = () => {
    if (document.querySelector('.image-modal')) return

    const modalHTML = `
      <div class="image-modal" role="dialog" aria-modal="true" aria-labelledby="modal-title">
        <div class="image-modal-backdrop"></div>
        <div class="image-modal-content">
          <div class="image-modal-header">
            <h3 id="modal-title" class="image-modal-title">Photo View</h3>
            <button 
              class="image-modal-close" 
              aria-label="Close modal" 
              title="Close (Esc)"
            >
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <button class="image-modal-nav image-modal-prev" aria-label="Previous image">&lt;</button>
          <button class="image-modal-nav image-modal-next" aria-label="Next image">&gt;</button>
          <img class="image-modal-image" src="" alt="Full size image">
          <div class="image-modal-caption"></div>
          <div class="image-modal-footer">
            <button class="image-modal-btn image-modal-close-btn" aria-label="Close">Close</button>
          </div>
        </div>
      </div>
    `
    document.body.insertAdjacentHTML('beforeend', modalHTML)
  }

  // Setup modal interaction - only called when modal is created
  const setupModal = () => {
    const modal = document.querySelector<HTMLDivElement>('.image-modal')
    if (!modal) return

    const modalImage =
      modal.querySelector<HTMLImageElement>('.image-modal-image')
    const modalCaption = modal.querySelector<HTMLDivElement>(
      '.image-modal-caption'
    )
    const modalTitle =
      modal.querySelector<HTMLHeadingElement>('.image-modal-title')
    const modalClose =
      modal.querySelector<HTMLButtonElement>('.image-modal-close')
    const modalCloseBtn = modal.querySelector<HTMLButtonElement>(
      '.image-modal-close-btn'
    )
    const modalBackdrop = modal.querySelector<HTMLDivElement>(
      '.image-modal-backdrop'
    )
    const prevButton =
      modal.querySelector<HTMLButtonElement>('.image-modal-prev')
    const nextButton =
      modal.querySelector<HTMLButtonElement>('.image-modal-next')

    // Safety check for required elements
    if (
      !modalImage ||
      !modalCaption ||
      !modalClose ||
      !modalCloseBtn ||
      !modalBackdrop ||
      !prevButton ||
      !nextButton ||
      !modalTitle
    ) {
      console.error('Modal elements not found')
      return
    }

    let currentIndex = -1
    const mosaicItems = Array.from(
      document.querySelectorAll<HTMLElement>('.mosaic-item')
    )

    // Preload the adjacent images when showing an image
    const preloadAdjacentImages = (index: number) => {
      const preloadIndex = (idx: number) => {
        if (idx < 0 || idx >= mosaicItems.length) return
        const item = mosaicItems[idx]
        if (!item) return
        const imgUrl = getImageUrl(item)
        if (!imgUrl) return

        const preloadImg = new Image()
        preloadImg.src = imgUrl
      }

      // Preload next and previous images
      if (index > 0) preloadIndex(index - 1)
      if (index < mosaicItems.length - 1) preloadIndex(index + 1)
    }

    // Function to get image URL from mosaic item - with memory caching
    const urlCache = new Map<HTMLElement, string>()
    const getImageUrl = (item: HTMLElement): string => {
      if (urlCache.has(item)) return urlCache.get(item) || ''

      const imageElement = item.querySelector<HTMLElement>('.mosaic-image')
      if (!imageElement) return ''

      const backgroundImage = getComputedStyle(imageElement).backgroundImage
      const url = backgroundImage.replace(/url\(['"]?(.*?)['"]?\)/i, '$1')
      urlCache.set(item, url)
      return url
    }

    // Function to update modal content
    const updateModalContent = (index: number): void => {
      const item = mosaicItems[index]
      if (!item) return

      const imageUrl = getImageUrl(item)
      const caption = item.getAttribute('data-caption') || ''
      const imageIndex = index + 1

      modalImage.src = imageUrl
      modalCaption.textContent = caption
      modalTitle.textContent = `Photo ${imageIndex} of ${mosaicItems.length}`
      currentIndex = index

      // Update navigation buttons
      prevButton.disabled = index === 0
      nextButton.disabled = index === mosaicItems.length - 1

      // Preload adjacent images for smoother navigation
      requestIdleCallback(
        () => {
          preloadAdjacentImages(index)
        },
        { timeout: 500 }
      )
    }

    // Close modal functions - reuse this function
    const closeModal = (): void => {
      modal.classList.remove('active')
      document.body.style.overflow = ''
      setTimeout(() => {
        modalImage.src = ''
        modalCaption.textContent = ''
        currentIndex = -1
      }, 300)
    }

    // Navigation functions
    const showPrevImage = (): void => {
      if (currentIndex > 0) {
        updateModalContent(currentIndex - 1)
      }
    }

    const showNextImage = (): void => {
      if (currentIndex < mosaicItems.length - 1) {
        updateModalContent(currentIndex + 1)
      }
    }

    // Add click handlers with event delegation
    modal.addEventListener('click', (e) => {
      const target = e.target as HTMLElement

      // Close button or backdrop click
      if (
        target === modalClose ||
        target === modalCloseBtn ||
        target === modalBackdrop ||
        target.closest('.image-modal-close') === modalClose ||
        target.closest('.image-modal-close-btn') === modalCloseBtn
      ) {
        closeModal()
      }

      // Previous button
      if (
        target === prevButton ||
        target.closest('.image-modal-prev') === prevButton
      ) {
        showPrevImage()
      }

      // Next button
      if (
        target === nextButton ||
        target.closest('.image-modal-next') === nextButton
      ) {
        showNextImage()
      }
    })

    // Handle mosaic image clicks with event delegation
    document.querySelector('.photo-mosaic')?.addEventListener('click', (e) => {
      const target = e.target as HTMLElement
      const mosaicItem = target.closest('.mosaic-item')

      if (!mosaicItem) return

      const index = mosaicItems.indexOf(mosaicItem as HTMLElement)
      if (index === -1) return

      updateModalContent(index)
      modal.classList.add('active')
      document.body.style.overflow = 'hidden'

      // Focus the close button for accessibility
      modalClose.focus()
    })

    // Keyboard navigation
    document.addEventListener('keydown', (e: KeyboardEvent) => {
      if (!modal.classList.contains('active')) return

      if (e.key === 'Escape') {
        closeModal()
      } else if (e.key === 'ArrowLeft') {
        showPrevImage()
      } else if (e.key === 'ArrowRight') {
        showNextImage()
      }
    })
  }

  // Lazy init - only create modal when first image is clicked
  document.querySelector('.photo-mosaic')?.addEventListener(
    'click',
    (e) => {
      const target = e.target as HTMLElement
      if (target.closest('.mosaic-item')) {
        if (!document.querySelector('.image-modal')) {
          createModal()
          setupModal()
        }
      }
    },
    { once: true }
  )
}
---

<!-- Photo Mosaic -->
<section class='photo-mosaic-section'>
  <div class='section-decorative-line'></div>
  <h2 class='section-title reveal-title'>Sweet Moments</h2>
  <div class='photo-mosaic'>
    {
      mosaicImages.map((num) => (
        <div
          class={`mosaic-item item${num}`}
          data-caption={`Photo ${num}`}
        >
          <div
            class='mosaic-image'
            data-src={`img/sweet/${num}.jpg`}
          />
        </div>
      ))
    }
  </div>
</section>

<script>
  // Create image cache to avoid redundant loads
  const imageCache = new Map<string, HTMLImageElement>()

  // IntersectionObserver options
  const observerOptions = {
    rootMargin: '100px', // Load images earlier
    threshold: 0.01, // Trigger with minimal visibility
  }

  // Single observer for all lazy-loaded images
  const setupLazyLoading = () => {
    const mosaicImages = document.querySelectorAll<HTMLElement>(
      '.mosaic-image[data-src]'
    )

    if ('IntersectionObserver' in window) {
      const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach((entry) => {
          if (!entry.isIntersecting) return

          const image = entry.target as HTMLElement
          const src = image.dataset.src

          if (src) {
            // Apply the background image
            image.style.backgroundImage = `url(${src})`

            // Remove data-src to mark as loaded
            delete image.dataset.src

            // Stop observing this element
            observer.unobserve(image)
          }
        })
      }, observerOptions)

      // Observe all images with data-src
      mosaicImages.forEach((image) => {
        imageObserver.observe(image)
      })
    } else {
      // Fallback for browsers without IntersectionObserver
      mosaicImages.forEach((image) => {
        const src = image.dataset.src
        if (src) {
          image.style.backgroundImage = `url(${src})`
          delete image.dataset.src
        }
      })
    }
  }

  // Animation observer - handles reveal animations
  const setupAnimationObserver = () => {
    const mosaicItems = document.querySelectorAll<HTMLElement>('.mosaic-item')

    if ('IntersectionObserver' in window) {
      const animationObserver = new IntersectionObserver(
        (entries, observer) => {
          entries.forEach((entry) => {
            if (!entry.isIntersecting) return

            const item = entry.target as HTMLElement

            // Use requestAnimationFrame for smoother animations
            requestAnimationFrame(() => {
              item.classList.add('visible')
            })

            observer.unobserve(item)
          })
        },
        observerOptions
      )

      // Observe all mosaic items
      mosaicItems.forEach((item) => {
        animationObserver.observe(item)
      })
    } else {
      // Fallback for browsers without IntersectionObserver
      mosaicItems.forEach((item) => {
        item.classList.add('visible')
      })
    }
  }

  // Hover effect with performance optimization
  const setupHoverEffects = () => {
    const mosaicItems = document.querySelectorAll<HTMLElement>('.mosaic-item')
    let activeHoverItem: HTMLElement | null = null

    // Using event delegation for better performance
    document
      .querySelector('.photo-mosaic')
      ?.addEventListener('mouseover', (e) => {
        const target = e.target as HTMLElement
        const item = target.closest('.mosaic-item') as HTMLElement

        if (item && activeHoverItem !== item) {
          if (activeHoverItem) {
            activeHoverItem.classList.remove('hover')
          }

          item.classList.add('hover')
          activeHoverItem = item
        }
      })

    document
      .querySelector('.photo-mosaic')
      ?.addEventListener('mouseleave', () => {
        if (activeHoverItem) {
          activeHoverItem.classList.remove('hover')
          activeHoverItem = null
        }
      })
  }

  // Initialize everything when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    // Setup lazy loading
    setupLazyLoading()

    // Setup animation observer
    setupAnimationObserver()

    // Setup hover effects
    setupHoverEffects()

    // Initialize image modal after document is loaded
    if (typeof initImageModal === 'function') {
      // Wait for the document to be interactive before initializing
      if (
        document.readyState === 'interactive' ||
        document.readyState === 'complete'
      ) {
        initImageModal()
      } else {
        document.addEventListener('DOMContentLoaded', initImageModal)
      }
    }
  })
</script>
